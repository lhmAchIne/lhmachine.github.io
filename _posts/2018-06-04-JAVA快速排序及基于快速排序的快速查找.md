---
title: JAVA快速排序及快速查找(QuickSearch)
author: lhmachine
date: 2018-06-04 16:14
categories:
- JAVA
tags:
- java
- 快速排序
- 快速查找
- QuickSearch
---

快速排序是对冒泡排序的一种改进，其**基本思想**是：通过一趟排序以数组某个关键数据为基准，将数组分为左右两个部分，一部分比关键数组大，一部分比关键数据小。然后按照此方法对数组两个部分再次进行快速排序，直至数组所有数据全部有序。

<!-- more -->

# 快速排序

## 算法介绍

以将数组从小到大排列，假设待排序数组为X，我们选取任一数据作为关键数据（通常是数组第一个元素，即A[0]），然后将数组中所有比关键数据小的数据放在关键数据的左边，将所有比关键数据大的数据放在关键数据的右边，此过程即为一次快速排序过程。

一趟快速排序的算法如下：

1. 设定前索引`low=0`，后索引`high = X.length-1`，以数据第一个元素作为关键数据`key = X[0]`，进行第2步；
2. 从数组最后一位往前搜索，即`high--`，直至`X[high] < key`，将`key`对应的数组元素`X[low]`（初始对应`X[0]`）与`X[high]`交换，`low++`，进行第3步；
3. 从数组最开始一位往后搜索，即`low++`，直至`X[low]>key`，将`X[high]`（注意此时`X[high]`在第2步中刚进行过交换，正对应着`key`）与`X[low]`交换，进行第4步；
4. 重复第3步，第4步，直至`low == high`；（注意在第三第四步中，要保持`low<high`，否则结束循环）。


注意：*快速排序不是一种稳定的排序算法，即多个相同值的相对位置在算法结束时可能会产生波动。*

## 算法复杂度分析

### 时间复杂度

由算法介绍可知，快速排序每趟排序将数组分为左右两个部分，则**理想情况**下，每一次都将待排序数组划分成等长两个部分，直到排序结束，共需要$ \log_2 n $次划分，此时快速排序的时间复杂度为 $ O(n \log n) $ 。然后**最坏情况下**，划分由 n 个元素构成的数组需要进行 n 次比较和 n 次移动。因此划分所需时间为 O(n)，此时每次划分只能减少一个元素，快速排序将不幸退化为冒泡排序，其时间复杂度为$ O(n^2) $。

### 空间复杂度

快速排序在对序列的操作过程中只需花费常数级的空间。空间复杂度S(1)。

## JAVA版代码

```java
public void sort(int[] nums, int low, int high) {
  int key = nums[low];		//第一位作为关键数据
  int i=low;					//暂存低位索引
  int j=high;					//暂存高位索引

  //一趟冒泡排序,直到i=j,此时i和j都是关键数据的索引
  while(i < j) {
    //从后往前搜索直到找到第一个比关键数据小的数据
    while(i<j && nums[j]>=key)
      j--;
    if (i<j) {
      //找到第一个比关键数据小的数据，如果j>i，则交换两个数据
      nums[i] = nums[j];
      nums[j] = key;
      i++;
    }

    //从前往后搜索直到找到第一个比关键数据大的数据
    while(i<j && nums[i]<=key)
      i++;
    if (i<j) {
      //找到第一个比关键数据大的数据，如果j>i，则交换两个数据
      nums[j] = nums[i];
      nums[i] = key;
      j--;
    }
  }

  if (j<high) {
    //如果此时关键数据作右边数据长度不为0，，继续排序，否则右半部分划分完毕
    sort(nums, i+1, high);
  }
  if (i>low) {
    //如果此时关键数据作左边数据长度不为0，，继续排序，否则左半部分划分完毕
    sort(nums, low, i-1);
  }
}
```



# 快速查找

基于快速排序下的快速查找，最通常的应用就是，*给定某个数组，查找数组中第K大的数据*。

## 算法介绍

由快速排序的算法介绍可知，快速排序的思想是，将待排序数组以关键数据为基准，将数据划分为两个部分，一部分比关键数据大，一部分比关键数据小。在此基础上，我们可以对此算法进行改进，即快速查找算法。

假设我们需要查找数组X中第K大的数据，我们先对数组进行一趟快速排序，则可以得到新的数组，数组中关键数据左边的数据都比关键数据小，关键数据右边的数据都比关键数据大。

在此基础上，假设数组中关键数据右边有`j`个数据，则此部分数据都比关键数据大。则可以分为以下三种情况：

- 若`j>=K`，则我们需要查找的第K大的数在关键数据的右边，可在右半部分再次进行一趟快速排序，查找第K大数据；
- 若`j+1 == k`，则关键数据即为第K大的数据；
- 若`j+1<K`，则第K大的数在关键数据的左边，可在左半部分再次进行一次快速排序，查找第K大数据；

循环上面的步骤，直至找到第K大数据即可。

## 算法复杂度分析

快速查找是在快速排序基础上进行的改进，但是相比于快速排序，快速查找每次只用对数组两部分中的一部分进行再次排序和查找，所以其时间复杂度$ T(n) = n+\frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \dots = 2N = O(n)$

其空间复杂度与快速排序一样，没有发生改变，仍为$ S(1) $。

## JAVA版代码

```java
	public int kthLargestElement(int k, int[] nums) {
        // write your code here
		int i=0;					//初始索引
		int j=nums.length-1;		//最后一位索引
		int key = nums[0];			//设置初始数据为关键数据
		int key_index=0;			//关键数据索引
		
		//一趟冒泡排序过程
		while(i < j) {
			while(i<j && nums[j]>=key)
				j--;
			if (i<j) {
				nums[i] = nums[j];
				nums[j] = key;
				key_index = j;			//存储关键数据索引
				i++;
			}
			
			while(i<j && nums[i]<=key)
				i++;
			if (i<j) {
				nums[j] = nums[i];
				nums[i] = key;
				key_index = i;			//存储关键数据索引
				j--;
			}
		}
		
		if (nums.length - key_index > k) {
			//如果右边数据长度+1大于K，则在右边数据部分查找
			return kthLargestElement(k, Arrays.copyOfRange(nums, key_index+1, nums.length));
		}else if (nums.length - key_index == k) {
			//如果右边数据长度+1等于K，则关键数据为所要查找的数据
			return nums[key_index];
		}else {
			//如果右边数据长度+1小于K，则在左边数据部分查找
			return kthLargestElement(k - (nums.length - key_index), Arrays.copyOfRange(nums, 0, key_index));
		}
		
    }
```