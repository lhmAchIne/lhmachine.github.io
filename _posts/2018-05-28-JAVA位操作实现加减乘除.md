---
title: JAVA位操作及加减乘除实现
author: lhmachine
date: 2018-05-28 18:08
categories: 
- JAVA
tags: 
- java
- 位操作
- 加减乘除
---

在计算机里面，所有的数据都是以二进制形式存储的，因而对数据进行位操作有时可以提高不少的计算速度。基本位操作有与、或、异或、取反、左移、右移6种。

# 数据存储

## 存储大小

1字节=8bit，由于java是跨平台语言，因此对与32位、64位两种操作系统，各种类型在不同操作系统下的数据长度是一致的。

|  类型  | int  | short | long | byte | float | double | char |
| :--: | :--: | :---: | :--: | :--: | :---: | :----: | :--: |
| 字节数  |  4   |   2   |  8   |  1   |   4   |   8    |  2   |

## 存储形式

对于整数类型（int、long）而言，数据位的最高位是符号位，**最高位为1表示负数，最高位为0表示正数** 。

- 原码：数值的二进制形式。如`(int)5`的原码即为`00000000 00000000 00000000 00000101` ，`(int)-1`的原码为`10000000 00000000 00000000 00000001` ；
- 反码：1）正数的反码就是原码；2）负数的反码是对数值的原码，除最高位符号位不变外，进行取反，如`(int)5`的反码为`00000000 00000000 00000000 00000101`，`(int)-1`的反码为` 11111111 11111111 11111111 11111110`；
- 补码：1）正数的补码就是原码；2）负数的补码是在反码的基础上加1，如`(int)5`的反码为`00000000 00000000 00000000 00000101`，`(int)-1`的反码为` 11111111 11111111 11111111 11111111`；

计算机在进行数值计算时，是通过**补码**形式表示每个数据。即

$$ \begin{aligned} 5-1 = 5+(-1)  = \\00000000 00000000 00000000 00000101 \\ + 11111111 11111111 11111111 11111111 \\ = 1 00000000 00000000 00000000 00000100 \end{aligned} $$

因为`int`只有4字节存储空间，最高位1会溢出，进位产生的1被丢弃，结果为`00000000 00000000 00000000 00001000`，即4。

# 位操作运算符

- **与**(`&`)：进行运算的两个数，从最低位到最高位一一对应，按照如下规则运算：` 1 & 1 = 1 `,   ` 1 & 0 = 0 ` , ` 0 & 0 = 0`。
- **或**(`|`)：进行运算的两个数，从最低位到最高位一一对应，运算规则如下：` 1 | 1 = 1 `,    ` 1 | 0 = 1 ` , ` 0 | 0 = 0`。
- **异或**(`^`)：进行运算的两个数，从最低位到最高位一一对应，运算规则如下：` 1 ^ 1 = 0 `,   ` 1 ^ 0 = 1 ` , `0 ^ 0 = 0`。
- **取反**(`~`)：对操作数的每一位取反，即`~1 = 0`, `~0 = 1`。
- **左移**(`<<`)：`a<<b`将数值a整体向左移动b位，最高位不变，低位空出来的位补0。
- **右移**(`>>`)：`a>>b`将数值a整体向右移动b位，最高位不变，高位空出来的位补0。

# 利用位操作实现加减乘除

## 加法(a+b)

在位操作中，`a^b`可以得到按位相加后没有进位的和，`a&b`可以得到a+b产生的进位数值（*注意，此进位不可直接相加*）。如`0+1 = 0^1 = 1`,`0+0 = 0^0 = 0`,  `1+1 = 1^1 = 0(进位为1&1 = 1)`。

因为进位的数值是加在当前位的前一位，因此`a&b`得到的进位数需要向左移动一位，即正确的进位数值为`a&b<<1`。

`1+1 = 10`， 即`1+1 = 1^1+1&1<<1 = 0 + 10 = 10`。

则对于数a和b，如果要实现a和b相加，则`a+b = a^b + (a&b)<<1`，对于`a^b + (a&b)<<1`可以看成又一个数a和b相加，直到`(a&b)<<1 = 0`。

若采用递归方式实现，如下所示：

```java
int aplusb(int a, int b){
    int result = 0;				//结果
    int xor = a^b;				//和
    int forward = (a&b)<<1;	    //进位
    if (forward == 0){
        result = xor;
    }else{
        result = aplusb(xor, forward);
    }
    return result;
}
```

若采用非递归方式，如下所示：

```java
int aplusb(int a, int b) {
    int xor = a^b;
    int forward = (a&b)<<1;
    while(forward != 0){
        a = xor;
        b = forward;
        xor = a^b;
        forward = (a&b)<<1;
    }
    return xor;
}
```

## 减法(a-b)

`a-b = a+(-b)`，可以看作是a加上-b，则可以用加法作计算。

## 乘法(a*b)

二进制乘法的原理：从乘数的低位到高位，遇到`1`(其位于乘数的右起第`i`位)，把被乘数左移`i`位得到一个乘积$ temp_i $，直到乘数中所有的`1`遍历完，将所有的乘积$ temp_i $相加即可。

例如：

```
    1010  (10)
 *  0110  (06)
 ------------
   10100  (1010<<1)
  101000  (1010<<2)
--------------
  111100  (60)
```

实现代码如下：

```java
int amultib(int a, int b){
    int result = 0;
    int i=0;
    while (b!=0){
    //乘数为0结束
        if ((b&1) == 1){
        //如果当前位为1
            result = result + (a<<i);
            b = b>>1;
            ++i;
        }else{
            b = b>>1;
            ++i;
        }
    }
    return result;
}
```

注意：此代码只适用于b为正数的情况。

## 除法(a/b)

假设`a/b = c`，则`a`等于`c`个`b`相加，则除法就是求`a`能由多少个`b`相加组成，则除法可以变形为求`a`减去多少个`b`为0。

代码如下：

```java
int adivb(int a, int b){
    int result = 0;
    if (a<b)
        result = 0;
    else{
        while (a!=0){
            a = a-b;
            result++;
        }
    }
    return result;
}
```

注意：此代码仅针对正数，并且可以整除的情况。